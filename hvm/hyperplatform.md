These are somes notes I made while reading [HyperPlatform](https://github.com/tandasat/HyperPlatform) source code.

- Request NX Non-Paged Pool when available using: ``` ExInitializeDriverRuntime(DrvRtPoolNxOptIn);```, a good practise when doing driver dev.
- Test if the system is one of supported OS versions(Vista+) + 4GT tuning should not be enabled in 32bits.
- Init page tables variables: PXE, PPE, PDE, PTE.
- Build the physical memory ranges.
- Register power callback routines dealing with hibernate and sleep states: ```\\Callback\\PowerState```.
- Register hot-plug/power callback for new processors using __KeRegisterProcessorChangeCallback__, same could be achieved by callign ExCreateCallback ```\\Callback\\PowerState```.
- Check if the HypervisorPresent bit is set: ```CPUID[1].ECX[31] == 1```.
- Check if hyperplatform is installed using CPUID with a custom code (0x40000001).
- Check if VMX bit is set: ```CPUID[1].ECX[5] == 1```.
- Check if write-back memory type is supported using: ```readmsr[0x480].memory_type```.
- Check if the lock-bit is set using ```readmsr[0x03A].lock``` and set it if not set.
- Check if __enable_vmxon__ bit id set from vmx_feature_control, if not this means probably that VT-x is not enabled by the BIOS.
- Check if EPT features are fully supported using ```readmsr[0x48C]```.
- Init some shared processor data: SharedProcessorData
    - Build the MSR bitmap (ignore IA32_MPERF+IA32_APERF+IA32_GS_BASE+IA32_KERNEL_GS_BASE)
    - Build the IO bitmap.
- Read and store all MTRRs to set a correct memory type for EPT using ```readmsr[0x2FF]```.
- Virtualize all processors (for each processor, execute a callback in PASSIVE_LEVEL):
    - Get count of CPUs: ```KeQueryActiveProcessorCountEx()```
    - Switch the current processor: ```KeSetSystemGroupAffinityThread()```
    - Execute the callback (VmpStartVm)
    - Switch back to previous processor: ```KeRevertToUserGroupAffinityThread()```.
- Initialize VM callback:
    - Allocate space for ProcessorData.
    - Set up EPT
    - Allocate space for VMM stack limit.
    - Allocate space for VMCS and VMXON region.
    - Enter VMX mode:
        - Apply FIXED bits in CR0 and CR4 by reading from these MSRs ___0x486, 0x487, 0x488, 0x489__.
        - Write a VMCS revision identifier for VMXON region using ```MSR[0x480].revision_identifier```.
        - Execute a ```__vmx_on(&vmxon_region_pa)```.
    - Initialize VMCS:
        - Write a VMCS revision identifier for VMCS resgion using ```MSR[0x480].revision_identifier```.
        - Execute a ```__vmx_vmclear(&vmcs_region_pa)``` then a ```__vmx_vmptrld(&vmcs_region_pa)```
    - Set up VMCS
    - Launch the VM:
        - UtilVmRead(VmcsField::kVmInstructionError);
        - Execute a ```__vmx_vmlaunch()```.
- After a VM-Exit happen, the VMM will execute starting from its EP: ```AsmVmmEntryPoint```
    - call VmmVmExitHandler
    - vxresume
- VMM VM-Exit handler:
    - Raise IRQL as quick as possible to DISPATCH_LEVEL:  ```KeRaiseIrqlToDpcLevel()```.
    - Get the exit reason: ```UtilVmRead(VmcsField::kVmExitReason)[0x00004402]```.
    - Capture the current guest state:
        - UtilVmRead (VmcsField::kGuestRflags)
        - UtilVmRead(VmcsField::kGuestRip)
        - UtilVmRead(VmcsField::kGuestRsp)
        - guest_cr8, guest_irql, stack
